/**
 * Experimental sliced state model for the upcoming v3 graph.
 *
 * This file defines **narrow** interfaces – each represents a coherent slice of
 * data that is produced/consumed by a bounded set of nodes.
 *
 * During the migration we will gradually switch node signatures from the big
 * `AgentState` bag-of-fields to compositions of these slices.  Nothing in the
 * current codebase *imports* this file yet, so it is safe to iterate without
 * breaking runtime.
 */

import type {
  Document,
  Message,
  MessagePair,
  RetrievalTask,
  SourceMetadata,
  RetrievalEvaluation,
  ToolRoutingDecision,
  ToolNecessityClassification,
} from '../types';

/* ------------------------------------------------------------------ */
/*  Core conversation slices                                          */
/* ------------------------------------------------------------------ */

export interface ConversationSlice {
  /**
   * Raw chat messages as received from the user or generated by the system.
   */
  messages: Message[];
}

export interface HistorySlice {
  /**
   * Structured pair-wise history (user ↔ assistant) used by some prompt
   * builders.  We keep this separate so we can eventually derive it on-demand
   * and drop it from persistent state.
   */
  chatHistory: MessagePair[];
}

/* ------------------------------------------------------------------ */
/*  Retrieval & context                                               */
/* ------------------------------------------------------------------ */

export interface RetrievalSlice {
  retrievals: RetrievalTask[];
  /**
   * Flattened list of chunks/docs that survived reranking and filtering.
   */
  docs: Document[];
  /**
   * Minimal metadata about the docs we surfaced to the LLM – useful for
   * streaming and analytics.
   */
  sources: SourceMetadata[];
}

/* ------------------------------------------------------------------ */
/*  Decision making & reasoning                                       */
/* ------------------------------------------------------------------ */

export interface ReasoningSlice {
  /** Free-form chain-of-thought snippets (only stored while dev-mode) */
  reasoning: string[];
  /** System instructions generated en-route (e.g. after rewrite) */
  instructions: string;
}

export interface RetrievalEvaluationSlice {
  retrievalEvaluation: RetrievalEvaluation;
}

export interface ToolDecisionSlice {
  toolNecessityClassification: ToolNecessityClassification;
  toolRoutingDecision: ToolRoutingDecision;
}

/* ------------------------------------------------------------------ */
/*  Generation                                                        */
/* ------------------------------------------------------------------ */
export interface GenerationSlice {
  generatedText: string;
}

/* ------------------------------------------------------------------ */
/*  Configuration & metadata                                          */
/* ------------------------------------------------------------------ */

export interface ConfigSlice {
  options: {
    enhanceWithContext: boolean;
    maxContextItems: number;
    includeSourceInfo: boolean;
    maxTokens: number;
    temperature?: number;
    modelId?: string;
  };
}

export interface MetadataSlice {
  metadata: {
    startTime?: number;
    nodeTimings?: Record<string, number>;
    tokenCounts?: Record<string, number>;
    currentNode?: string;
    isFinalState?: boolean;
    errors?: Array<{
      node: string;
      message: string;
      timestamp: number;
    }>;
    traceId?: string;
    spanId?: string;
    executionTimeMs?: number;
    route?: string;
    /**
     * Loop counter for iterative retrieval in Graph v3.
     */
    iteration?: number;
  };
}

/* ------------------------------------------------------------------ */
/*  Identity                                                          */
/* ------------------------------------------------------------------ */
export interface IdentitySlice {
  userId: string;
}

/* ------------------------------------------------------------------ */
/*  Composed experimental state                                       */
/* ------------------------------------------------------------------ */

export interface TaskSlice {
  taskIds?: string[];
  taskEntities?: Record<string, import('../types').UserTaskEntity>;
}

export interface ToolRequirementsSlice {
  toolRequirements?: Record<string, any>;
}

export type AgentStateV3 = IdentitySlice &
  ConversationSlice &
  Partial<
    HistorySlice &
      RetrievalSlice &
      ReasoningSlice &
      RetrievalEvaluationSlice &
      ToolDecisionSlice &
      GenerationSlice
  > &
  ConfigSlice &
  MetadataSlice &
  TaskSlice &
  ToolRequirementsSlice;

/**
 * Utility: list of all slice keys so other tooling can reference them without
 * hard-coding strings.
 */
export const sliceKeys = [
  'userId',
  'messages',
  'chatHistory',
  'retrievals',
  'docs',
  'sources',
  'reasoning',
  'instructions',
  'retrievalEvaluation',
  'toolNecessityClassification',
  'toolRoutingDecision',
  'generatedText',
  'options',
  'metadata',
  'taskIds',
  'taskEntities',
  'toolRequirements',
] as const;

/* ------------------------------------------------------------------ */
/*  Utility Types                                                     */
/* ------------------------------------------------------------------ */

/**
 * Helper generic for node return types.
 *
 * SliceUpdate<'docs' | 'sources'>  →  { docs?: Document[]; sources?: SourceMetadata[]; metadata?: MetadataSlice['metadata'] }
 *
 * Always allows returning a (partial) `metadata` slice so nodes can set
 * timing and bookkeeping info without having to include it explicitly.
 */
export type SliceUpdate<K extends keyof AgentStateV3 = never> = Partial<
  Pick<AgentStateV3, K | 'metadata'>
>;
