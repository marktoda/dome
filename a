{"time":"2025-04-27T14:21:15.008Z","level":30,"component":"ChatController","result":{"userId":"cli-user","messages":[{"role":"user","content":"how does the compact work"},{"role":"user","content":"how does the compact work"},{"lc":1,"type":"constructor","id":["langchain_core","messages","AIMessage"],"kwargs":{"content":"It seems like you're asking about a \"compact,\" but it's unclear what specific type or context you're referring to. The term \"compact\" can refer to several things, such as:\n\n1. **Compact Disc (CD):** A digital optical disc storage format used to store and play back digital audio recordings.\n\n2. **Compact Car:** A classification for a small car, which is larger than a subcompact car but smaller than a mid-size car.\n\n3. **Interstate Compact:** An agreement between two or more U.S. states, often requiring congressional approval, to address and manage shared concerns or resources.\n\n4. **Compact Machine:** A piece of machinery or equipment designed to be smaller or take up less space than standard models.\n\n5. **Mathematical Compactness:** In mathematics, particularly in topology, a space is compact if every open cover of the space has a finite subcover.\n\n6. **Makeup Compact:** A small cosmetic case, often containing face powder, a mirror, and sometimes a puff for application.\n\nIf you can provide more context or specify which type of compact you are referring to, I can give a more detailed explanation.","additional_kwargs":{},"response_metadata":{"tokenUsage":{"promptTokens":21,"completionTokens":233,"totalTokens":254},"finish_reason":"stop","model_name":"gpt-4o-2024-08-06","usage":{"prompt_tokens":21,"completion_tokens":233,"total_tokens":254,"prompt_tokens_details":{"cached_tokens":0,"audio_tokens":0},"completion_tokens_details":{"reasoning_tokens":0,"audio_tokens":0,"accepted_prediction_tokens":0,"rejected_prediction_tokens":0}},"system_fingerprint":"fp_55d88aaf2f"},"id":"chatcmpl-BQxAUp4LW6c1D28GeVSovZMTDtWjt","tool_calls":[],"invalid_tool_calls":[],"usage_metadata":{"output_tokens":233,"input_tokens":21,"total_tokens":254,"input_token_details":{"audio":0,"cache_read":0},"output_token_details":{"audio":0,"reasoning":0}}}}],"options":{"enhanceWithContext":true,"maxContextItems":5,"includeSourceInfo":true,"maxTokens":1000,"temperature":0.7},"tasks":{"originalQuery":"how does the compact work","rewrittenQuery":"how does the compact work","queryAnalysis":{"isComplex":false,"shouldSplit":false,"reason":"The query is vague but not complex, as it centers on understanding the function or mechanism of a single, unspecified item referred to as 'the compact'.","suggested":[]},"needsWidening":false,"wideningAttempts":0},"docs":[{"id":"01JSJT643JE0VSXJN9A2T307FK","title":"---DOME-METADATA-START---","body":"---DOME-METADATA-START---\n{\n  \"source\": {\n    \"type\": \"github\",\n    \"repository\": \"uniswap/the-compact\",\n    \"path\": \"README.md\",\n    \"updated_at\": \"2025-03-12T20:21:49Z\"\n  },\n  \"content\": {\n    \"type\": \"code\",\n    \"language\": \"markdown\",\n    \"size_bytes\": 58336\n  },\n  \"ingestion\": {\n    \"timestamp\": \"2025-04-24T02:31:21.385Z\",\n    \"version\": \"1.0\"\n  }\n}\n---DOME-METADATA-END---\n\n# The Compact ð¤\n - **Compact** *[noun]*: an agreement or covenant between two or more parties.\n - **Compact** *[transitive verb]*: to make up by connecting or combining.\n - **Compact** *[adjective]*: occupying a small volume by reason of efficient use of space.\n\n> :warning: This is an early-stage contract under active development; it has not yet been properly tested, reviewed, or audited.\n\n## Summary\nThe Compact is an ownerless ERC6909 contract that facilitates the voluntary formation (and, if necessary, eventual dissolution) of reusable resource locks.\n\nResource locks are entered into by ERC20 or native token holders, called the _**depositor**_. Once a resource lock has been established, the owner of the ERC6909 token representing a resource lock can act as a _**sponsor**_ and create a _**compact**_. A compact is a commitment allowing interested parties to claim their tokens through the sponsor's indicated _**arbiter**_. The arbiter is then responsible for processing the claim once it has attested to the specified conditions of the compact having been met.\n\nEach resource lock is mediated by an _**allocator**_, tasked with attesting to the availability of the underlying token balances and preserving the balances required for the commitments they have attested to; in other words, an allocator ensures that sponsors do not \"double-spend,\" transfer, or withdraw any token balances that are already committed to a specific compact.\n\nOnce a sponsor and their designated allocator have both committed to a compact, a _**claimant**_ may then immediately perform the attached condition (such as delivering another token on some destination chain) and then claim the allocated tokens by initiating a call to the associated arbiter, which will verify and mediate the terms and conditions of the associated compact and relay the confirmation to process the claim.\n\nThe Compact effectively \"activates\" any deposited tokens to be instantly spent or swapped across arbitrary, asynchronous environments as long as:\n - the claimant is confident that the allocator is sound and will not leave the resource lock underallocated,\n - the sponsor is confident that the arbiter is sound and will not process claims where the conditions were not successfully met,\n - the claimant is confident that the arbiter is sound and will not *fail* to process claims where the conditions *were* successfully met, and\n - the sponsor is confident that the allocator will not unduly censor fully allocated requests.\n\nSponsors have recourse from potential censorship in the form of a \"forced withdrawal.\" When depositing tokens into a resource lock, the sponsor provides a \"reset period\" as a parameter. Then, the sponsor can initiate a forced withdrawal at any point; after the reset period has elapsed, the full token balance can be withdrawn regardless of any pending claims on their balance. In the case of cross-chain swaps, reset periods only need to be long enough for the claim to finalize (generally some multiple of the slowest blockchain involved in the swap).\n\nClaimants must bear varying degrees of trust assumptions with regards to allocators, with the potential design space including reputation-based systems, trusted execution environments, smart-contract-based systems, or even dedicated rollups. The Compact takes a neutral stance on implementations of both allocators and arbiters, enabling support for a wide variety of potential applications while ensuring adherence to a consistent interface when integrating with the system as a whole.\n\n## Setup\n```\n# install foundry if needed\n$ curl -L https://foundry.paradigm.xyz | bash\n\n# clone repo\n$ git clone git@github.com:Uniswap/the-compact.git && cd the-compact\n\n# install dependencies & libraries\n$ forge install\n\n# run basic tests\n$ forge test\n```\n\n## Usage\nVersion 0 of The Compact is currently deployed on mainnet, Sepolia, Unichain, Unichain Sepolia, Optimism, OP Sepolia, Base, and Base Sepolia at `0x00000000000018DF021Ff2467dF97ff846E09f48`. As long as the prerequisite deployer contract and Permit2 are deployed to a given chain, The Compact can be deployed to any new chain by running `forge script script/TheCompact.s.sol`.\n\n### 1) Register an Allocator\nTo begin using The Compact, an allocator must first be registered on the contract. Anyone can register any account as an allocator by calling the `__register` function as long as one of the following requirements are met:\n - the allocator being registered is the caller\n - the allocator being registered is a contract with code deployed to it\n - a `CREATE2` address derivation proof for the allocator's address is provided as part of the call.\n\nOnce an allocator has been registered on a given chain for the first time, it will be assigned a 92-bit \"allocator ID\" that resource locks will use to reference it.\n\n> Note that multiple allocators may register the same allocator ID across different chains if their addresses are very similar; a mechanic for collision resistance is available whereby the number of leading zero \"nibbles\" above three is encoded in the first four bits of the allocator ID. This implies that any allocator with nine leading zero bytes has a unique allocator ID.\n\nA given allocator only needs to be registered once per chain and can then be utilized by many different resource locks.\n\nThe allocator's primary function is to ensure that any resource locks it is assigned to are not \"double-spent\" â this entails ensuring that sufficient unallocated balance is available before cosigning on any requests to withdraw or transfer the balance or to sponsor a claim on that balance, and also ensuring that nonces are not reused. Allocators can also call a `consume` method at any point to consume nonces so that they cannot be used again.\n\n### 2) Deposit tokens\nTo enter into The Compact and create resource locks, a depositor begins by selecting for their four preferred properties for the lock:\n - the _**underlying token**_ held in the resource lock\n - the _**allocator**_ tasked with cosigning on claims against the resource locks and ensuring that the resource lock is not \"double-spent\" in any capacity, indicated by its registered allocator ID\n - the _**scope**_ of the resource lock (either spendable on any chain or limited to a single chain, with a default option of being spendable on any chain)\n - the _**reset period**_ for forceably exiting the lock and withdrawing the funds without the allocator's approval (one of eight preset values ranging from one second to thirty days, with a default option of ten minutes)\n\nEach unique combination of these four properties is represented by a fungible ERC6909 tokenID.\n\nDepending on the selected properties of the resource lock, the number of tokens being placed into resource locks, and the source of token allowances for those tokens, the depositor then calls one of seven `deposit` functions:\n - a basic, payable deposit function that uses native tokens and the default scope and reset period parameters and supplies an allocator for the resource lock, where the caller is the recipient of the 6909 tokens representing ownership of the lock\n - a basic, non-payable deposit function that supplies an ERC20 token (with sufficient allowance set directly on The Compact) and amount to deposit in the resource lock, along with an allocator and the default scope and reset period parameters, where the caller is the recipient of the 6909 tokens representing ownership of the lock\n - a payable deposit function that uses native tokens and specifies the allocator, the scope, the reset period, and the recipient of the 6909 tokens representing ownership of the lock\n  - a non-payable deposit function that supplies an ERC20 token (with sufficient allowance set directly on The Compact) and amount to deposit in the resource lock, and that specifies the allocator, the scope, the reset period, and the recipient of the 6909 tokens representing ownership of the lock\n - a payable deposit function that specifies an array of 6909 IDs representing resource locks and deposit amounts for each id (with sufficient allowance set directly on The Compact for each ERC20 token) and the recipient of the 6909 tokens representing ownership of each lock\n - a non-payable deposit function that supplies an ERC20 token, amount, and associated Permit2 signature data (with sufficient allowance set on Permit2), and that specifies the allocator, the scope, the reset period, and the recipient of the 6909 tokens representing ownership of the lock (all of which are included as part of the Permit2 witness)\n - a payable deposit function that supplies an array of tokens and amounts (including an optional native token followed by any number of ERC20 tokens), and associated Permit2 batch signature data (with sufficient allowance set on Permit2 for each ERC20 token), and that specifies the allocator, the scope, the reset period, and the recipient of the 6909 tokens representing ownership of each lock (all of which are included as part of the Permit2 witness).\n\nThere are also five `depositAndRegister` functions that simultaneously perform a deposit into a resource lock and register a compact (see section 3b).\n\n > For ERC20 deposits, the amount of 6909 tokens minted is based on the change in the actual token balance held by The Compact after making the deposit, not the supplied amount; this enables support for making deposits of fee-on-transfer tokens where the fee is deducted from the recipient.\n\nAs long as allocators generally operate in an honest and reliable manner, this is the only direct interaction that end users will need to take; furthermore, in the case of the Permit2 deposit methods, the interaction can be made in a gasless fashion (where another party relays the signed message on behalf of the depositor).\n\n### X) Perform a Forced Withdrawal\nAt any point after depositing tokens, if an allocator goes down or refuses to cosign for a given claim against a resource lock, the depositor can initiate and process a forced withdrawal subject to the reset period on the resource lock.\n\nFirst, the depositor calls `enableForcedWithdrawal` and supplies the ID of the associated resource lock. At this point, their allocator will almost certainly cease cosigning for any sponsored claims from that depositor, and fillers will similarly avoid fulfilling new claim requests, but any inflight claims will still be able to be processed as long as the reset period on the resource lock is sufficient.\n\nNext, the depositor calls `forcedWithdrawal` and supplies the id, amount, and recipient; assuming the reset period has transpired from the point when the forced withdrawal was enabled, the underlying tokens will be sent to the recipient and a corresponding amount of 6909 tokens held by the caller will be burned.\n\n > For ERC20 withdrawals, the amount of 6909 tokens burned is based on the change in the actual token balance held by The Compact after making the withdrawal, not the supplied amount; this enables support for making withdrawals of fee-on-transfer tokens where the fee is deducted from the sender.\n\n Finally, if the original depositor wants to \"reactivate\" the resource lock, they can call `disableForcedWithdrawal` and supply the ID of the resource lock, returning the lock to the default state and preventing forced withdrawals until it is reactivated again.\n\n### Y) Perform a Standard Transfer\nEach ERC6909 token ID representing a specific set of resource lock parameters can be transferred like any other token; however, there is one additional requirement that must be met. The Compact will perform a call to the allocator before performing the transfer, and that allocator must attest to the transfer before it can proceed; this is necessary to prevent the invalidation of inflight claims on the resource lock.\n\n```solidity\ninterface IAllocator {\n    // Called on standard transfers; must return this function selector (0x1a808f91).\n    function attest(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external returns (bytes4);\n}\n```\n\n> Note: this is a stateful callback; care must be taken on the part of the allocator to avoid situations that could lead to an overallocated outcome via reentrancy or other unintended side effects.\n\n### 3) Create a Compact\nOnce a resource lock (or group of resource locks) has been established, the owner of the lock can enter into an agreement where the resource lock (or resource locks) will become claimable upon meeting the specified conditions.\n\n ### 3a) Sign a Compact\n In the default case, the owner and allocator of a resource lock both agree on a given course of action and attest to it by signing one of three EIP-712 payloads:\n  - a **Compact** deals with a specific resource lock and designates an **arbiter** tasked with verifying that the necessary conditions have been met choosing which accounts will receive the tokens and in what quantities\n  - a **BatchCompact** deals with a set of resource locks on a single chain and also designates an arbiter\n  - a **MultichainCompact** deals with a set of resource locks across multiple chains and designates a distinct arbiter for each chain.\n\nIn this context, the owner is referred to as the **sponsor** as they are sponsoring a claim against the resource lock, and each beneficiary or recipient of a portion of the claim is referred to as a **claimant**.\n\n```solidity\n// Message signed by the sponsor that specifies the conditions under which their\n// tokens can be claimed; the specified arbiter verifies that those conditions\n// have been met and specifies a set of beneficiaries that will receive up to the\n// specified amount of tokens.\nstruct Compact {\n    address arbiter; // The account tasked with verifying and submitting the claim.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 amount; // The amount of ERC6909 tokens to allocate.\n    // Optional witness may follow.\n}\n\n// Message signed by the sponsor that specifies the conditions under which a set of\n// tokens, each sharing an allocator, can be claimed; the specified arbiter verifies\n// that those conditions have been met and specifies a set of beneficiaries that will\n// receive up to the specified amounts of each token.\nstruct BatchCompact {\n    address arbiter; // The account tasked with verifying and submitting the claim.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    uint256[2][] idsAndAmounts; // The allocated token IDs and amounts.\n    // Optional witness may follow.\n}\n\n// A multichain compact can declare tokens and amounts to allocate from multiple chains,\n// each designated by their chainId. Any allocated tokens on an exogenous domain (e.g. all\n// but the first segment) must designate the Multichain scope. Each segment may designate\n// a unique arbiter for the chain in question. Note that the witness data is distinct for\n// each segment, but all segments must share the same EIP-712 witness typestring.\nstruct Segment {\n    address arbiter; // The account tasked with verifying and submitting the claim.\n    uint256 chainId; // The chainId where the tokens are located.\n    uint256[2][] idsAndAmounts; // The allocated token IDs and amounts.\n    // Optional witness may follow.\n}\n\n// Message signed by the sponsor that specifies the conditions under which a set of\n// tokens across a number of different chains can be claimed; the specified arbiter on\n// each chain verifies that those conditions have been met and specifies a set of\n// beneficiaries that will receive up to the specified amounts of each token.\nstruct MultichainCompact {\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    Segment[] segments; // Arbiter, chainId, ids & amounts, and witness for each chain.\n}\n```\n\nTo be considered valid, each compact must meet the following requirements:\n - the arbiter must submit the call (`arbiter == msg.sender`)\n - the sponsor must sign the EIP-712 payload (either ECDSA or EIP-1271) or submit the call (i.e. `arbiter == sponsor`)\n - the allocator must sign the EIP-712 payload (either ECDSA or EIP-1271) or a qualified payload referencing it, or submit the call (i.e. `arbiter == allocator`)\n - the compact cannot be expired (`expires > block.timestamp`)\n - the nonce cannot have been used previously\n\nOnce this payload has been signed by both the sponsor and the allocator (or at least by one party if the other is the intended caller), a claim can be submitted against it by the designated arbiter using a wide variety of functions (104 to be exact) depending on the type of compact and the intended result.\n\n### 3b) Submit a Compact Directly\nAlternatively, the sponsor can register a compact (or group of compacts) by submitting a \"claim hash\" along with the typehash of the underlying compact (which maps to the EIP-712 message hash that would otherwise have been signed). Then, instead of supplying the signature of the sponsor as part of a claim, The Compact derives the claim hash based on the claim being submitted and attempts to locate a matching registered claim hash with the correct typehash. This flow supports more advanced functionality, such as sponsors without the ability to sign (like protocols or DAOs), smart wallet / EIP7702-enabled sponsors that have their own authorization or batching logic, and chained deposit & register operations. When registering a compact directly, a duration is either explicitly provided or inferred from the reset period on the corresponding deposit where available; the registered compact becomes inactive once that duration elapses.\n\n> Note: once registered, a compact cannot be unregistered. The only way to definitively cancel a registered compact is by either having the allocator consume the attached nonce or waiting for the registered compact to expire. Alternatively, the sponsor may perform a forced withdrawal to render the compact unclaimable until tokens are placed back into the resource lock.\n\n### 4) Submit a Claim\nAn arbiter takes a signed compact designated to them and uses it to submit a claim to The Compact.\n\n### 4a) Allocated Transfer & Allocated Withdrawal\nIn the most straightforward variety of claim, where the arbiter is the sponsor, there are three key factors that result in eight distinct endpoints:\n - transfer vs. withdrawal: whether to transfer the ERC6909 tokens directly, or to withdraw the underlying tokens (e.g. calling `allocatedTransfer` or `allocatedWithdrawal`)\n - whether or not to perform a \"split\": with no split, the caller specifies a single recipient, whereas with a split the caller specifies multiple recipients and respective amounts\n - whether or not the compact in question is a \"batch\" compact: with a batch compact, multiple resource locks and respective amounts are involved in the claim.\n\n ```solidity\nstruct BasicTransfer {\n    bytes allocatorSignature; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    uint256 amount; // The token amount to transfer or withdraw.\n    address recipient; // The recipient of the transfer or withdrawal.\n}\n\nstruct SplitTransfer {\n    bytes allocatorSignature; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    SplitComponent[] recipients; // The recipients and amounts of each transfer.\n}\n\nstruct SplitComponent {\n    address claimant; // The recipient of the transfer or withdrawal.\n    uint256 amount; // The amount of tokens to transfer or withdraw.\n}\n\nstruct BatchTransfer {\n    bytes allocatorSignature; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    TransferComponent[] transfers; // The token IDs and amounts to transfer.\n    address recipient; // The recipient of the batch transfers.\n}\n\nstruct TransferComponent {\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    uint256 amount; // The token amount to transfer or withdraw.\n}\n\nstruct SplitBatchTransfer {\n    bytes allocatorSignature; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    SplitByIdComponent[] transfers; // The recipients and amounts of each transfer for each ID.\n}\n\nstruct SplitByIdComponent {\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    SplitComponent[] portions; // claimants and amounts.\n}\n\n interface ICompactAllocatedTransferAndWithdrawal {\n    function allocatedTransfer(BasicTransfer calldata transfer) external returns (bool);\n    function allocatedWithdrawal(BasicTransfer calldata withdrawal) external returns (bool);\n    function allocatedTransfer(SplitTransfer calldata transfer) external returns (bool);\n    function allocatedWithdrawal(SplitTransfer calldata withdrawal) external returns (bool);\n    function allocatedTransfer(BatchTransfer calldata transfer) external returns (bool);\n    function allocatedWithdrawal(BatchTransfer calldata withdrawal) external returns (bool);\n    function allocatedTransfer(SplitBatchTransfer calldata transfer) external returns (bool);\n    function allocatedWithdrawal(SplitBatchTransfer calldata withdrawal) external returns (bool);\n }\n ```\n\n### 4b) Single Resource Lock Claims\nWhen the arbiter is *not* necessarily the sponsor, and when the sponsor is only utilizing a single resource lock on a specific chain, the sponsor will sign a `Compact` EIP-712 payload. From that starting point, there are four key factors that result in sixteen distinct endpoints using two function names and eight input struct types:\n - transfer vs. withdrawal: whether to transfer the claimed ERC6909 tokens directly, or to withdraw the underlying claimed tokens (e.g. calling `claim` or `claimAndWithdraw`)\n - unqualified vs qualified: whether the allocator is cosigning the same claim hash as the sponsor, or if they are signing for additional data. This can be an arbitrary EIP-712 payload, with one exception: the first element must be the claim hash, which will be provided by The Compact directly as part of signature verification. These claims take two additional arguments: the EIP-712 typehash used in the qualification, and the data payload (not including the first claim hash argument). This data can then be utilized by the arbiter to inform and constrain the claim.\n - no witness vs. witness: whether or not the sponsor has elected to extend the Compact EIP-712 payload with an additional witness argument (generally using a new struct). When witness data is utilized, the call takes two additional arguments: one representing the EIP-712 hash of the witness data (or the direct data if it is a single value) and one representing the additional EIP-712 typestring that will extend the default arguments to include the witness.\n - whether or not to perform a \"split\": with no split, the caller specifies a single recipient, whereas with a split the caller specifies multiple recipients and respective amounts.\n\n\n```solidity\nstruct AllClaimsStartWith {\n    bytes allocatorSignature; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    // rest of the parameters follow ...\n}\n\nstruct BasicClaim {\n    bytes allocatorSignature; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    address claimant; // The claim recipient; specified by the arbiter.\n    uint256 amount; // The claimed token amount; specified by the arbiter.\n}\n\nstruct QualifiedClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 4 parameters as BasicClaim\n}\n\nstruct ClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    // ... same last 4 parameters as BasicClaim\n}\n\nstruct QualifiedClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 4 parameters as BasicClaim\n}\n\nstruct SplitClaim {\n    // ... same first 5 parameters as all claims\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    SplitComponent[] claimants; // The claim recipients and amounts; specified by the arbiter.\n}\n\nstruct QualifiedSplitClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 3 parameters as SplitClaim\n}\n\nstruct SplitClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    // ... same last 3 parameters as SplitClaim\n}\n\nstruct QualifiedSplitClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 3 parameters as SplitClaim\n}\n\ninterface ICompactClaims {\n    function claim(BasicClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(BasicClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedClaim calldata claimPayload) external returns (bool);\n    function claim(ClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(SplitClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedSplitClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedSplitClaim calldata claimPayload) external returns (bool);\n    function claim(SplitClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedSplitClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedSplitClaimWithWitness calldata claimPayload) external returns (bool);\n}\n```\n\n### 4c) Multiple Resource Lock Claims for a Single Chain\nWhen the sponsor is utilizing multiple resource locks on a specific chain, they will sign a `BatchCompact` EIP-712 payload. There are another sixteen endpoints that map to the same combination as the single-resource lock cases.\n\n```solidity\nstruct BatchClaim {\n    bytes allocatorSignature; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    BatchClaimComponent[] claims; // IDs and amounts.\n    address claimant; // The claim recipient; specified by the arbiter.\n}\n\nstruct BatchClaimComponent {\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    uint256 amount; // The claimed token amount; specified by the arbiter.\n}\n\nstruct QualifiedBatchClaim {\n    // ... same first 5 parameters as all claims\n    uint256 expires; // The time at which the claim expires.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    BatchClaimComponent[] claims; // IDs and amounts.\n    address claimant; // The claim recipient; specified by the arbiter.\n}\n\nstruct BatchClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    BatchClaimComponent[] claims; // IDs and amounts.\n    address claimant; // The claim recipient; specified by the arbiter.\n}\n\nstruct QualifiedBatchClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    BatchClaimComponent[] claims; // IDs and amounts.\n    address claimant; // The claim recipient; specified by the arbiter.\n}\n\nstruct SplitBatchClaim {\n    // ... same first 5 parameters as all claims\n    SplitBatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n}\n\nstruct SplitBatchClaimComponent {\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    SplitComponent[] portions; // claimants and amounts.\n}\n\nstruct SplitBatchClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    SplitBatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n}\n\nstruct QualifiedSplitBatchClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    SplitBatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n}\n\nstruct QualifiedSplitBatchClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    SplitBatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n}\n\ninterface ICompactBatchClaims {\n    function claim(BatchClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(BatchClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedBatchClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedBatchClaim calldata claimPayload) external returns (bool);\n    function claim(BatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(BatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedBatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedBatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(SplitBatchClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitBatchClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedSplitBatchClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedSplitBatchClaim calldata claimPayload) external returns (bool);\n    function claim(SplitBatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitBatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedSplitBatchClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedSplitBatchClaimWithWitness calldata claimPayload) external returns (bool);\n}\n```\n\n#### 4c) Single Resource Lock Claim on Multiple Chains\nWhen the sponsor wants to utilize multiple resource locks where each lock is on its own chain, they will sign a `MultichainCompact` EIP-712 payload that contains an array of `Allocation` structs, where each allocation indicates a specific arbiter, chainId, and array of length 1 containing the ID of the respective lock and an amount. The sponsor must sign the payload against the domain of the first allocation's chainId (called the \"notarized\" domain), and any subsequent allocations can only include resource locks with a \"Multichain\" scope. The allocator must sign the payload for each chain independently using its respective domain; these signatures can also each be uniquely qualified if necessary.\n\nThere are thirty-two endpoints in this scenario, broken into two groups of sixteen that each map to the same combination as the cases above:\n    - sixteen \"endogenous\" versions that utilize the initial resource lock and therefore are considered \"notarized\": these take a single additional argument, an `additionalChains` array containing the additional allocation hashes (the initial allocation hash is excluded as it is derived as part of validation).\n    - sixteen \"exogenous\" versions that utilize subsequent resource locks outside of the \"notarized\" domain; these also take an `additionalChains` array (the allocation hash for the chain being claimed against is excluded, as it is derived as part of validation) as well as two additional arguments:\n        - a `chainIndex` argument indicating the index to insert the allocation hash of the current domain (a value of `0` indicates that it is the second allocation, an index of `1` indicates that it is the third allocation, etc)\n        - a `notarizedChainId` argument indicating the chainId of the domain used by the sponsor to authorize the claim\n\n```solidity\nstruct MultichainClaim {\n    bytes allocatorSignature; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    address claimant; // The claim recipient; specified by the arbiter.\n    uint256 amount; // The claimed token amount; specified by the arbiter.\n}\n\nstruct ExogenousMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 4 parameters as MultichainClaim\n}\n\nstruct QualifiedMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 5 parameters as MultichainClaim\n}\n\nstruct ExogenousQualifiedMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 4 parameters as MultichainClaim\n}\n\nstruct MultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    // ... same last 5 parameters as MultichainClaim\n}\n\nstruct ExogenousMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 4 parameters as MultichainClaim\n}\n\nstruct QualifiedMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 5 parameters as MultichainClaim\n}\n\nstruct ExogenousQualifiedMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 4 parameters as MultichainClaim\n}\n\nstruct SplitMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    SplitComponent[] claimants; // The claim recipients and amounts; specified by the arbiter.\n}\n\nstruct ExogenousSplitMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 3 parameters as MultichainSplitClaim\n}\n\nstruct SplitMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    // ... same last 4 parameters as SplitMultichainClaim\n}\n\nstruct ExogenousQualifiedSplitMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 3 parameters as MultichainSplitClaim\n}\n\nstruct ExogenousSplitMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 3 parameters as MultichainSplitClaim\n}\n\nstruct QualifiedSplitMultichainClaim {\n    // ... same first 5 parameters as all claims\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 4 parameters as SplitMultichainClaim\n}\n\nstruct QualifiedSplitMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    // ... same last 4 parameters as SplitMultichainClaim\n}\n\nstruct ExogenousQualifiedSplitMultichainClaimWithWitness {\n    // ... same first 5 parameters as all claims\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    bytes32 qualificationTypehash; // Typehash of the qualification payload.\n    bytes qualificationPayload; // Data used to derive qualification hash.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current allocation hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n    // ... same last 3 parameters as MultichainSplitClaim\n}\n\ninterface ICompactMultichainClaims {\n    function claim(MultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(MultichainClaim calldata claimPayload) external returns (bool);\n    function claim(ExogenousMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(ExogenousQualifiedMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousQualifiedMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(MultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(MultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(ExogenousMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(ExogenousQualifiedMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousQualifiedMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(SplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(ExogenousSplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousSplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedSplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedSplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(ExogenousQualifiedSplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(SplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(ExogenousSplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousSplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedSplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedSplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(ExogenousQualifiedSplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n}\n```\n\n> Note: Given that sponsors sign a single payload covering multiple chains, they are only able to designate a single EIP-712 witness. If multiple chains require distinct witnesses, the parent witness will need to leverage a nested struct containing each child chain's respective witness or another similar scheme. Allocators can still easily provide distinct qualifications per-chain, as they still sign for each chain independently.\n\n### 4d) Multiple Resource Lock Claim on Multiple Chains\nFinally, there are thirty-two claim endpoints to cover cases where the sponsor is utilizing multiple resource locks against multiple chains where one or more chains contain more than one resource lock; these also utilize a `MultichainCompact` EIP-712 payload, but the `Allocation` structs can contain `idsAndAmounts` arrays of arbitrary length.\n\n```solidity\nstruct BatchMultichainClaim {\n    bytes allocatorSignature; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32[] additionalChains; // The allocation hashes from additional chains.\n    BatchClaimComponent[] claims; // IDs and amounts.\n    address claimant; // The claim recipient; specified by the arbiter.\n}\n\n// ... additional structs omitted for brevity ...\n\ninterface ICompactBatchMultichainClaims{\n    function claim(BatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(BatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(ExogenousBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(QualifiedBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(ExogenousQualifiedBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claim(BatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(BatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(ExogenousBatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousBatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(QualifiedBatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(QualifiedBatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(ExogenousQualifiedBatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaimWithWitness calldata claimPayload) external returns (bool);\n    function claim(SplitBatchMultichainClaim calldata claimPayload) external returns (bool);\n    function claimAndWithdraw(SplitBatchMultichainClaim calldata claimPayload) external returns (bool);\n   ...","metadata":{"source":"code","createdAt":"1970-01-21T04:51:01.910Z","relevanceScore":0.6813274,"url":null,"mimeType":"text/markdown","tokenCount":12751}},{"id":"01JSJT643JQTZSMHSJVPZCEWC3","title":"---DOME-METADATA-START---","body":"---DOME-METADATA-START---\n{\n  \"source\": {\n    \"type\": \"github\",\n    \"repository\": \"uniswap/the-compact\",\n    \"path\": \"src/lib/DepositViaPermit2Logic.sol\",\n    \"updated_at\": \"2024-11-05T03:29:09Z\"\n  },\n  \"content\": {\n    \"type\": \"code\",\n    \"language\": \"plaintext\",\n    \"size_bytes\": 28401\n  },\n  \"ingestion\": {\n    \"timestamp\": \"2025-04-24T02:31:27.390Z\",\n    \"version\": \"1.0\"\n  }\n}\n---DOME-METADATA-END---\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\nimport { DepositLogic } from \"./DepositLogic.sol\";\nimport { DepositViaPermit2Lib } from \"./DepositViaPermit2Lib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\n/**\n * @title DepositViaPermit2Logic\n * @notice Inherited contract implementing internal functions with logic for processing\n * token deposits via permit2. These deposits leverage Permit2 witness data to either\n * indicate the parameters of the lock to deposit into and the recipient of the deposit,\n * or the parameters of the compact to register alongside the deposit. Deposits can also\n * involve a single ERC20 token or a batch of tokens in a single Permit2 authorization.\n * @dev IMPORTANT NOTE: this logic operates directly on unallocated memory, and reads\n * directly from fixed calldata offsets; proceed with EXTREME caution when making any\n * modifications to either this logic contract (including the insertion of new logic) or\n * to the associated permit2 deposit function interfaces!\n */\ncontract DepositViaPermit2Logic is DepositLogic {\n    using DepositViaPermit2Lib for bytes32;\n    using DepositViaPermit2Lib for uint256;\n    using IdLib for uint256;\n    using IdLib for address;\n    using IdLib for ResetPeriod;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using RegistrationLib for address;\n    using ValidityLib for address;\n    using SafeTransferLib for address;\n\n    // Selector for the single token `permit2.permitWitnessTransferFrom` function.\n    uint32 private constant _PERMIT_WITNESS_TRANSFER_FROM_SELECTOR = 0x137c29fe;\n\n    // Address of the Permit2 contract.\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens using Permit2 authorization. The\n     * depositor must approve Permit2 to transfer the tokens on its behalf unless the token in\n     * question automatically grants approval to Permit2. The ERC6909 token amount received by the\n     * by the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token. The Permit2 authorization signed by the\n     * depositor must contain a CompactDeposit witness containing the allocator, the reset period,\n     * the scope, and the intended recipient of the deposit.\n     * @param token       The address of the ERC20 token to deposit.\n     * @param recipient   The address that will receive the corresponding the ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposit.\n     * @return            The ERC6909 token identifier of the associated resource lock.\n     */\n    function _depositViaPermit2(address token, address recipient, bytes calldata signature) internal returns (uint256) {\n        // Derive the CompactDeposit witness hash.\n        bytes32 witness = uint256(0xa4).asStubborn().deriveCompactDepositWitnessHash();\n\n        // Set reentrancy lock, get initial balance, and begin preparing Permit2 call data.\n        (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation) = _setReentrancyLockAndStartPreparingPermit2Call(token);\n\n        // Insert the CompactDeposit typestring fragment.\n        typestringMemoryLocation.insertCompactDepositTypestring();\n\n        // Store the CompactDeposit witness hash.\n        assembly (\"memory-safe\") {\n            mstore(add(m, 0x100), witness)\n        }\n\n        // Write the signature and perform the Permit2 call.\n        _writeSignatureAndPerformPermit2Call(m, uint256(0x140).asStubborn(), uint256(0x200).asStubborn(), signature);\n\n        // Deposit tokens based on the balance change from the Permit2 call.\n        _checkBalanceAndDeposit(token, recipient, id, initialBalance);\n\n        // Clear reentrancy lock.\n        _clearReentrancyGuard();\n\n        // Return the ERC6909 token identifier of the associated resource lock.\n        return id;\n    }\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens using Permit2 authorization and\n     * registering a compact. The depositor must approve Permit2 to transfer the tokens on its\n     * behalf unless the token in question automatically grants approval to Permit2. The ERC6909\n     * token amount received by the depositor is derived from the difference between the starting\n     * and ending balance held in the resource lock, which may differ from the amount transferred\n     * depending on the implementation details of the respective token. The Permit2 authorization\n     * signed by the depositor must contain an Activation witness containing the id of the resource\n     * lock and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param token           The address of the ERC20 token to deposit.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param resetPeriod     The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposit.\n     * @return                The ERC6909 token identifier of the associated resource lock.\n     */\n    function _depositAndRegisterViaPermit2(\n        address token,\n        address depositor, // also recipient\n        ResetPeriod resetPeriod,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) internal returns (uint256) {\n        // Set reentrancy lock, get initial balance, and begin preparing Permit2 call data.\n        (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation) = _setReentrancyLockAndStartPreparingPermit2Call(token);\n\n        // Continue preparing Permit2 call data and get activation and compact typehashes.\n        (bytes32 activationTypehash, bytes32 compactTypehash) = typestringMemoryLocation.writeWitnessAndGetTypehashes(compactCategory, witness, bool(false).asStubborn());\n\n        // Derive the activation witness hash and store it.\n        activationTypehash.deriveAndWriteWitnessHash(id, claimHash, m, 0x100);\n\n        // Derive signature offset value.\n        uint256 signatureOffsetValue;\n        assembly (\"memory-safe\") {\n            signatureOffsetValue := and(add(mload(add(m, 0x160)), 0x17f), not(0x1f))\n        }\n\n        // Write the signature and perform the Permit2 call.\n        _writeSignatureAndPerformPermit2Call(m, uint256(0x140).asStubborn(), signatureOffsetValue, signature);\n\n        // Deposit tokens based on the balance change from the Permit2 call.\n        _checkBalanceAndDeposit(token, depositor, id, initialBalance);\n\n        // Register the compact.\n        depositor.registerCompact(claimHash, compactTypehash, resetPeriod);\n\n        // Clear reentrancy lock.\n        _clearReentrancyGuard();\n\n        // Return the ERC6909 token identifier of the associated resource lock.\n        return id;\n    }\n\n    /**\n     * @notice Internal function for depositing multiple tokens using Permit2 authorization in a\n     * single transaction. The first token id can optionally represent native tokens by providing\n     * the null address and an amount matching msg.value. The depositor must approve Permit2 to\n     * transfer the tokens on its behalf unless the tokens automatically grant approval to\n     * Permit2. The ERC6909 token amounts received by the recipient are derived from the\n     * differences between starting and ending balances held in the resource locks, which may\n     * differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * CompactDeposit witness containing the allocator, the reset period, the scope, and the\n     * intended recipient of the deposits.\n     * @param permitted   Array of token permissions specifying the deposited tokens and amounts.\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposits.\n     * @return            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function _depositBatchViaPermit2(ISignatureTransfer.TokenPermissions[] calldata permitted, address recipient, bytes calldata signature) internal returns (uint256[] memory) {\n        // Set reentrancy guard, perform initial native deposit if present, and get initial token balances.\n        (uint256 totalTokensLessInitialNative, bool firstUnderlyingTokenIsNative, uint256[] memory ids, uint256[] memory initialTokenBalances) = _preprocessAndPerformInitialNativeDeposit(permitted, recipient);\n\n        // Derive the CompactDeposit witness hash.\n        bytes32 witness = uint256(0x84).asStubborn().deriveCompactDepositWitnessHash();\n\n        // Begin preparing Permit2 call data.\n        (uint256 m, uint256 typestringMemoryLocation) = totalTokensLessInitialNative.beginPreparingBatchDepositPermit2Calldata(firstUnderlyingTokenIsNative);\n\n        // Insert the CompactDeposit typestring fragment.\n        typestringMemoryLocation.insertCompactDepositTypestring();\n\n        // Declare variable for signature offset value.\n        uint256 signatureOffsetValue;\n        assembly (\"memory-safe\") {\n            // Store the CompactDeposit witness hash.\n            mstore(add(m, 0x80), witness)\n\n            // Derive signature offset value.\n            signatureOffsetValue := add(0x220, shl(7, totalTokensLessInitialNative))\n        }\n\n        // Write the signature and perform the Permit2 call.\n        _writeSignatureAndPerformPermit2Call(m, uint256(0xc0).asStubborn(), signatureOffsetValue, signature);\n\n        // Deposit tokens based on balance changes from Permit2 call and clear reentrancy lock.\n        _verifyBalancesAndPerformDeposits(ids, permitted, initialTokenBalances, recipient, firstUnderlyingTokenIsNative);\n\n        // Return the ERC6909 token identifiers of the associated resource locks.\n        return ids;\n    }\n\n    /**\n     * @notice Internal function for depositing multiple tokens using Permit2 authorization and\n     * registering a compact in a single transaction. The first token id can optionally represent\n     * native tokens by providing the null address and an amount matching msg.value. The depositor\n     * must approve Permit2 to transfer the tokens on its behalf unless the tokens automatically\n     * grant approval to Permit2. The ERC6909 token amounts received by the depositor are derived\n     * from the differences between starting and ending balances held in the resource locks, which\n     * may differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * BatchActivation witness containing the ids of the resource locks and an associated\n     * Compact, BatchCompact, or MultichainCompact payload matching the specified compact category.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted       Array of token permissions specifying the deposited tokens and amounts.\n     * @param resetPeriod     The duration after which the resource locks can be reset once forced withdrawals are initiated.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposits.\n     * @return                Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function _depositBatchAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        ResetPeriod resetPeriod,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) internal returns (uint256[] memory) {\n        // Set reentrancy guard, perform initial native deposit if present, and get initial token balances.\n        (uint256 totalTokensLessInitialNative, bool firstUnderlyingTokenIsNative, uint256[] memory ids, uint256[] memory initialTokenBalances) = _preprocessAndPerformInitialNativeDeposit(permitted, depositor);\n\n        // Derive the hash of the resource lock ids.\n        uint256 idsHash;\n        assembly (\"memory-safe\") {\n            idsHash := keccak256(add(ids, 0x20), shl(5, add(totalTokensLessInitialNative, firstUnderlyingTokenIsNative)))\n        }\n\n        // Begin preparing Permit2 call data.\n        (uint256 m, uint256 typestringMemoryLocation) = totalTokensLessInitialNative.beginPreparingBatchDepositPermit2Calldata(firstUnderlyingTokenIsNative);\n\n        // Prepare the typestring fragment and get batch activation and compact typehashes.\n        (bytes32 activationTypehash, bytes32 compactTypehash) = typestringMemoryLocation.writeWitnessAndGetTypehashes(compactCategory, witness, bool(true).asStubborn());\n\n        // Derive the batch activation witness hash and store it.\n        activationTypehash.deriveAndWriteWitnessHash(idsHash, claimHash, m, 0x80);\n\n        // Declare variable for signature offset value.\n        uint256 signatureOffsetValue;\n        assembly (\"memory-safe\") {\n            // Get the length of the witness.\n            let witnessLength := witness.length\n\n            // Derive the total memory offset for the witness.\n            let totalWitnessMemoryOffset := and(add(add(0xf3, add(witnessLength, iszero(iszero(witnessLength)))), add(mul(eq(compactCategory, 1), 0x0b), shl(6, eq(compactCategory, 2)))), not(0x1f))\n\n            // Derive the signature offset value.\n            signatureOffsetValue := add(add(0x180, shl(7, totalTokensLessInitialNative)), totalWitnessMemoryOffset)\n        }\n\n        // Write the signature and perform the Permit2 call.\n        _writeSignatureAndPerformPermit2Call(m, uint256(0xc0).asStubborn(), signatureOffsetValue, signature);\n\n        // Deposit tokens based on balance changes from Permit2 call and clear reentrancy lock.\n        _verifyBalancesAndPerformDeposits(ids, permitted, initialTokenBalances, depositor, firstUnderlyingTokenIsNative);\n\n        // Register the compact.\n        depositor.registerCompact(claimHash, compactTypehash, resetPeriod);\n\n        // Return the ERC6909 token identifiers of the associated resource locks.\n        return ids;\n    }\n\n    /**\n     * @notice Private function for pre-processing and performing an initial native deposit.\n     * @param permitted                     Array of token permissions specifying the deposited tokens and amounts.\n     * @param recipient                     The address that will receive the corresponding ERC6909 tokens.\n     * @return totalTokensLessInitialNative The total number of tokens less the initial native deposit.\n     * @return firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     * @return ids                          Array of ERC6909 token identifiers.\n     * @return initialTokenBalances         Array of initial token balances.\n     */\n    function _preprocessAndPerformInitialNativeDeposit(ISignatureTransfer.TokenPermissions[] calldata permitted, address recipient)\n        private\n        returns (uint256 totalTokensLessInitialNative, bool firstUnderlyingTokenIsNative, uint256[] memory ids, uint256[] memory initialTokenBalances)\n    {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Get total number of tokens and declare allocator, reset period, & scope variables.\n        uint256 totalTokens = permitted.length;\n        address allocator;\n        ResetPeriod resetPeriod;\n        Scope scope;\n\n        assembly (\"memory-safe\") {\n            // Get the offset of the permitted calldata struct.\n            let permittedOffset := permitted.offset\n\n            // Determine if the first underlying token is native.\n            firstUnderlyingTokenIsNative := iszero(shr(96, shl(96, calldataload(permittedOffset))))\n\n            // Revert if:\n            //  * the array is empty\n            //  * the callvalue is zero but the first token is native\n            //  * the callvalue is nonzero but the first token is non-native\n            //  * the first token is non-native and the callvalue doesn't equal the first amount\n            if or(iszero(totalTokens), or(eq(firstUnderlyingTokenIsNative, iszero(callvalue())), and(firstUnderlyingTokenIsNative, iszero(eq(callvalue(), calldataload(add(permittedOffset, 0x20))))))) {\n                // revert InvalidBatchDepositStructure()\n                mstore(0, 0xca0fc08e)\n                revert(0x1c, 0x04)\n            }\n\n            // Retrieve allocator, reset period, & scope.\n            // NOTE: these may need to be sanitized if toIdIfRegistered doesn't already handle for it\n            allocator := calldataload(0x84)\n            resetPeriod := calldataload(0xa4)\n            scope := calldataload(0xc4)\n        }\n\n        // Get the initial resource lock id.\n        uint256 initialId = address(0).toIdIfRegistered(scope, resetPeriod, allocator);\n\n        // Allocate ids array.\n        ids = new uint256[](totalTokens);\n\n        // Perform initial native deposit if present.\n        if (firstUnderlyingTokenIsNative) {\n            _deposit(recipient, initialId, msg.value);\n\n            // Set the initial id using the native resource lock.\n            ids[0] = initialId;\n        }\n\n        // Calculate total number of tokens less the initial native deposit.\n        unchecked {\n            totalTokensLessInitialNative = totalTokens - firstUnderlyingTokenIsNative.asUint256();\n        }\n\n        // Prepare ids and get initial token balances.\n        initialTokenBalances = _prepareIdsAndGetBalances(ids, totalTokensLessInitialNative, firstUnderlyingTokenIsNative, permitted, initialId);\n    }\n\n    /**\n     * @notice Private function for setting the reentrancy guard and starting the process\n     *  of preparing a Permit2 call.\n     * @param token                      The address of the token to be deposited.\n     * @return id                        The ERC6909 token identifier of the associated resource lock.\n     * @return initialBalance            The initial balance of the token in the contract.\n     * @return m                         The memory pointer for the Permit2 call data.\n     * @return typestringMemoryLocation  The memory location for the typestring.\n     */\n    function _setReentrancyLockAndStartPreparingPermit2Call(address token) private returns (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation) {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Declare allocator, reset period, & scope variables.\n        address allocator;\n        ResetPeriod resetPeriod;\n        Scope scope;\n\n        // Retrieve allocator, reset period, & scope.\n        assembly (\"memory-safe\") {\n            allocator := calldataload(0xa4)\n            resetPeriod := calldataload(0xc4)\n            scope := calldataload(0xe4)\n        }\n\n        // Get the ERC6909 token identifier of the associated resource lock.\n        id = token.excludingNative().toIdIfRegistered(scope, resetPeriod, allocator);\n\n        // Get the initial balance of the token in the contract.\n        initialBalance = token.balanceOf(address(this));\n\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            m := mload(0x40)\n\n            // Begin preparing Permit2 call data.\n            mstore(m, _PERMIT_WITNESS_TRANSFER_FROM_SELECTOR)\n            calldatacopy(add(m, 0x20), 0x04, 0x80) // token, amount, nonce, deadline\n            mstore(add(m, 0xa0), address())\n            mstore(add(m, 0xc0), calldataload(0x24)) // amount\n            mstore(add(m, 0xe0), calldataload(0x84)) // depositor\n            mstore(add(m, 0x120), 0x140)\n\n            // Derive the memory location for the typestring.\n            typestringMemoryLocation := add(m, 0x160)\n\n            // NOTE: strongly consider allocating memory here as the inline assembly scope\n            // is being left (it *should* be fine for now as the function between assembly\n            // blocks does not allocate any new memory).\n        }\n    }\n\n    /**\n     * @notice Private function for writing the signature and performing the Permit2 call.\n     * @param m                       The memory pointer for the Permit2 call data.\n     * @param signatureOffsetLocation The memory location for the signature offset.\n     * @param signatureOffsetValue    The signature offset value.\n     * @param signature               The Permit2 signature.\n     */\n    function _writeSignatureAndPerformPermit2Call(uint256 m, uint256 signatureOffsetLocation, uint256 signatureOffsetValue, bytes calldata signature) private {\n        // Determine if Permit2 is deployed.\n        bool isPermit2Deployed = _isPermit2Deployed();\n\n        assembly (\"memory-safe\") {\n            // Write the signature offset.\n            mstore(add(m, signatureOffsetLocation), signatureOffsetValue) // signature offset\n\n            // Retrieve signature length and derive signature memory offset.\n            let signatureLength := signature.length\n            let signatureMemoryOffset := add(m, add(0x20, signatureOffsetValue))\n\n            // Write the signature length.\n            mstore(signatureMemoryOffset, signatureLength)\n\n            // Copy the signature from calldata to memory.\n            calldatacopy(add(signatureMemoryOffset, 0x20), signature.offset, signatureLength)\n\n            // Perform the Permit2 call.\n            if iszero(and(isPermit2Deployed, call(gas(), _PERMIT2, 0, add(m, 0x1c), add(0x24, add(signatureOffsetValue, signatureLength)), 0, 0))) {\n                // Bubble up if the call failed and there's data.\n                // NOTE: consider evaluating remaining gas to protect against revert bombing\n                if returndatasize() {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert Permit2CallFailed();\n                mstore(0, 0x7f28c61e)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Private function for verifying balance changes and performing deposits.\n     * @param ids                          The ERC6909 token identifiers of the associated resource locks.\n     * @param permittedTokens              The token permissions specifying the deposited tokens and amounts.\n     * @param initialTokenBalances         The initial token balances in the contract.\n     * @param recipient                    The address that will receive the corresponding ERC6909 tokens.\n     * @param firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     */\n    function _verifyBalancesAndPerformDeposits(\n        uint256[] memory ids,\n        ISignatureTransfer.TokenPermissions[] calldata permittedTokens,\n        uint256[] memory initialTokenBalances,\n        address recipient,\n        bool firstUnderlyingTokenIsNative\n    ) private {\n        // Declare token balance, initial balance, and error buffer variables.\n        uint256 tokenBalance;\n        uint256 initialBalance;\n        uint256 errorBuffer;\n\n        // Retrieve total initial token balances (equal to total tokens less initial native deposit).\n        uint256 totalTokensLessInitialNative = initialTokenBalances.length;\n\n        unchecked {\n            // Iterate through each token.\n            for (uint256 i = 0; i < totalTokensLessInitialNative; ++i) {\n                // Get the token balance and initial balance.\n                tokenBalance = permittedTokens[i + firstUnderlyingTokenIsNative.asUint256()].token.balanceOf(address(this));\n                initialBalance = initialTokenBalances[i];\n\n                // Set the error buffer if the initial balance is greater than or equal to the token balance.\n                errorBuffer |= (initialBalance >= tokenBalance).asUint256();\n\n                // Perform the deposit.\n                _deposit(recipient, ids[i + firstUnderlyingTokenIsNative.asUint256()], tokenBalance - initialBalance);\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Revert if the error buffer is set.\n            if errorBuffer {\n                // revert InvalidDepositBalanceChange()\n                mstore(0, 0x426d8dcf)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Clear reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Private function for preparing ids and getting token balances.\n     * Note that all tokens must be supplied in ascending order and cannot be duplicated.\n     * @param ids                          The ERC6909 token identifiers of the associated resource locks.\n     * @param totalTokensLessInitialNative The total number of tokens less the initial native deposit.\n     * @param firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     * @param permitted                    The token permissions specifying the deposited tokens and amounts.\n     * @param id                           The ERC6909 token identifier of the associated resource lock.\n     * @return tokenBalances               The token balances in the contract.\n     */\n    function _prepareIdsAndGetBalances(uint256[] memory ids, uint256 totalTokensLessInitialNative, bool firstUnderlyingTokenIsNative, ISignatureTransfer.TokenPermissions[] calldata permitted, uint256 id)\n        private\n        view\n        returns (uint256[] memory tokenBalances)\n    {\n        unchecked {\n            // Allocate token balances array.\n            tokenBalances = new uint256[](totalTokensLessInitialNative);\n\n            // Declare token, candidate id, and error buffer variables.\n            address token;\n            uint256 candidateId;\n            uint256 errorBuffer;\n\n            // Iterate over each token.\n            for (uint256 i = 0; i < totalTokensLessInitialNative; ++i) {\n                // Retrieve the token and derive the candidate id.\n                token = permitted[i + firstUnderlyingTokenIsNative.asUint256()].token;\n                candidateId = id.withReplacedToken(token);\n\n                // Set the error buffer if the candidate id is less than or equal to the current id.\n                errorBuffer |= (candidateId <= id).asUint256();\n\n                // Update the id.\n                id = candidateId;\n\n                // Set the id in the ids array.\n                ids[i + firstUnderlyingTokenIsNative.asUint256()] = id;\n\n                // Get the token balance and set it in the token balances array.\n                tokenBalances[i] = token.balanceOf(address(this));\n            }\n\n            assembly (\"memory-safe\") {\n                // Revert if the error buffer is set.\n                if errorBuffer {\n                    // revert InvalidDepositTokenOrdering()\n                    mstore(0, 0x0f2f1e51)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n}\n","metadata":{"source":"code","createdAt":"1970-01-21T04:51:01.913Z","relevanceScore":0.6587243,"url":null,"mimeType":"application/solidity","tokenCount":7209}},{"id":"01JSJT643J0PSGKZTNGPJCSTEA","title":"---DOME-METADATA-START---","body":"---DOME-METADATA-START---\n{\n  \"source\": {\n    \"type\": \"github\",\n    \"repository\": \"uniswap/the-compact\",\n    \"path\": \"src/interfaces/ITheCompact.sol\",\n    \"updated_at\": \"2024-11-05T03:29:09Z\"\n  },\n  \"content\": {\n    \"type\": \"code\",\n    \"language\": \"plaintext\",\n    \"size_bytes\": 36714\n  },\n  \"ingestion\": {\n    \"timestamp\": \"2025-04-24T02:31:27.112Z\",\n    \"version\": \"1.0\"\n  }\n}\n---DOME-METADATA-END---\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ForcedWithdrawalStatus } from \"../types/ForcedWithdrawalStatus.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport { BasicTransfer, SplitTransfer } from \"../types/Claims.sol\";\n\nimport { BatchTransfer, SplitBatchTransfer } from \"../types/BatchClaims.sol\";\n\n/**\n * @title The Compact â Core Interface\n * @custom:version 0 (early-stage proof-of-concept)\n * @author 0age (0age.eth)\n * @notice The Compact is an ownerless ERC6909 contract that facilitates the voluntary\n * formation and mediation of reusable \"resource locks.\" This interface contract specifies\n * external functions for making deposits, for performing allocated transfers and\n * withdrawals, for initiating and performing forced withdrawals, and for registering\n * compact claim hashes and typehashes directly. It also contains methods for registering\n * allocators and for enabling allocators to consume nonces directly. Finally, it specifies\n * a number of view functions, events and errors.\n */\ninterface ITheCompact {\n    /**\n     * @notice Event indicating that a claim has been processed for a given compact.\n     * @param sponsor    The account sponsoring the claimed compact.\n     * @param allocator  The account mediating the resource locks utilized by the claim.\n     * @param arbiter    The account verifying and initiating the settlement of the claim.\n     * @param claimHash  A bytes32 hash derived from the details of the claimed compact.\n     */\n    event Claim(address indexed sponsor, address indexed allocator, address indexed arbiter, bytes32 claimHash);\n\n    /**\n     * @notice Event indicating a change in forced withdrawal status.\n     * @param account        The account for which the withdrawal status has changed.\n     * @param id             The ERC6909 token identifier of the associated resource lock.\n     * @param activating     Whether the forced withdrawal is being activated or has been deactivated.\n     * @param withdrawableAt The timestamp when tokens become withdrawable if it is being activated.\n     */\n    event ForcedWithdrawalStatusUpdated(address indexed account, uint256 indexed id, bool activating, uint256 withdrawableAt);\n\n    /**\n     * @notice Event indicating that a compact has been registered directly.\n     * @param sponsor   The address registering the compact in question.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @param expires   The timestamp at which the compact can no longer be claimed.\n     */\n    event CompactRegistered(address indexed sponsor, bytes32 claimHash, bytes32 typehash, uint256 expires);\n\n    /**\n     * @notice Event indicating an allocator has been registered.\n     * @param allocatorId The unique identifier assigned to the allocator.\n     * @param allocator   The address of the registered allocator.\n     */\n    event AllocatorRegistered(uint96 allocatorId, address allocator);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock\n     * and receiving back ERC6909 tokens representing the underlying locked balance controlled\n     * by the depositor. The allocator mediating the lock is provided as an argument, and the\n     * default reset period (ten minutes) and scope (multichain) will be used for the resource\n     * lock. The ERC6909 token amount received by the caller will match the amount of native\n     * tokens sent with the transaction.\n     * @param allocator The address of the allocator.\n     * @return id The ERC6909 token identifier of the associated resource lock.\n     */\n    function deposit(address allocator) external payable returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock\n     * and simultaneously registering a compact. The allocator, the claim hash, and the typehash\n     * used for the claim hash are provided as additional arguments, and the default reset period\n     * (ten minutes) and scope (multichain) will be used for the resource lock. The ERC6909 token\n     * amount received by the caller will match the amount of native tokens sent with the transaction.\n     * @param allocator The address of the allocator.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositAndRegister(address allocator, bytes32 claimHash, bytes32 typehash) external payable returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens into a resource lock. The default\n     * reset period (ten minutes) and scope (multichain) will be used. The caller must directly\n     * approve The Compact to transfer a sufficient amount of the ERC20 token on its behalf. The\n     * ERC6909 token amount received back by the caller is derived from the difference between\n     * the starting and ending balance held in the resource lock, which may differ from the amount\n     * transferred depending on the implementation details of the respective token.\n     * @param token     The address of the ERC20 token to deposit.\n     * @param allocator The address of the allocator mediating the resource lock.\n     * @param amount    The amount of tokens to deposit.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function deposit(address token, address allocator, uint256 amount) external returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * compact. The default reset period (ten minutes) and scope (multichain) will be used. The\n     * caller must directly approve The Compact to transfer a sufficient amount of the ERC20 token\n     * on its behalf. The ERC6909 token amount received back by the caller is derived from the\n     * difference between the starting and ending balance held in the resource lock, which may differ\n     * from the amount transferred depending on the implementation details of the respective token.\n     * @param token     The address of the ERC20 token to deposit.\n     * @param allocator The address of the allocator mediating the resource lock.\n     * @param amount    The amount of tokens to deposit.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositAndRegister(address token, address allocator, uint256 amount, bytes32 claimHash, bytes32 typehash) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock with\n     * custom reset period and scope parameters. The ERC6909 token amount received by the recipient\n     * will match the amount of native tokens sent with the transaction.\n     * @param allocator   The address of the allocator mediating the resource lock.\n     * @param resetPeriod The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @return id         The ERC6909 token identifier of the associated resource lock.\n     */\n    function deposit(address allocator, ResetPeriod resetPeriod, Scope scope, address recipient) external payable returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens into a resource lock with custom reset\n     * period and scope parameters. The caller must directly approve The Compact to transfer a\n     * sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount received by\n     * the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token.\n     * @param token       The address of the ERC20 token to deposit.\n     * @param allocator   The address of the allocator mediating the resource lock.\n     * @param resetPeriod The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param amount      The amount of tokens to deposit.\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @return id         The ERC6909 token identifier of the associated resource lock.\n     */\n    function deposit(address token, address allocator, ResetPeriod resetPeriod, Scope scope, uint256 amount, address recipient) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens in a single transaction.\n     * The first entry in idsAndAmounts can optionally represent native tokens by providing the\n     * null address and an amount matching msg.value. For ERC20 tokens, the caller must directly\n     * approve The Compact to transfer sufficient amounts on its behalf. The ERC6909 token amounts\n     * received by the recipient are derived from the differences between starting and ending\n     * balances held in the resource locks, which may differ from the amounts transferred depending\n     * on the implementation details of the respective tokens.\n     * @param idsAndAmounts Array of [id, amount] pairs with each pair indicating the resource lock and amount to deposit.\n     * @param recipient     The address that will receive the corresponding ERC6909 tokens.\n     * @return              Whether the batch deposit was successfully completed.\n     */\n    function deposit(uint256[2][] calldata idsAndAmounts, address recipient) external payable returns (bool);\n\n    /**\n     * @notice External payable function for depositing multiple tokens in a single transaction\n     * and registering a set of claim hashes. The first entry in idsAndAmounts can optionally\n     * represent native tokens by providing the null address and an amount matching msg.value. For\n     * ERC20 tokens, the caller must directly approve The Compact to transfer sufficient amounts\n     * on its behalf. The ERC6909 token amounts received by the recipient are derived from the\n     * differences between starting and ending balances held in the resource locks, which may\n     * differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. Note that resource lock ids must be supplied in alphanumeric order.\n     * @param idsAndAmounts           Array of [id, amount] pairs with each pair indicating the resource lock and amount to deposit.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @param duration                The duration for which the claim hashes remain valid.\n     * @return                        Whether the batch deposit and claim hash registration was successfully completed.\n     */\n    function depositAndRegister(uint256[2][] calldata idsAndAmounts, bytes32[2][] calldata claimHashesAndTypehashes, uint256 duration) external payable returns (bool);\n\n    /**\n     * @notice External function for depositing ERC20 tokens using Permit2 authorization. The\n     * depositor must approve Permit2 to transfer the tokens on its behalf unless the token in\n     * question automatically grants approval to Permit2. The ERC6909 token amount received by the\n     * by the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token. The Permit2 authorization signed by the\n     * depositor must contain a CompactDeposit witness containing the allocator, the reset period,\n     * the scope, and the intended recipient of the deposit.\n     * @param token       The address of the ERC20 token to deposit.\n     * @param amount      The amount of tokens to deposit.\n     * @param nonce       The Permit2 nonce for the signature.\n     * @param deadline    The timestamp until which the signature is valid.\n     * @param depositor   The account signing the permit2 authorization and depositing the tokens.\n     * @param allocator   The address of the allocator mediating the resource lock.\n     * @param resetPeriod The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param recipient   The address that will receive the corresponding the ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposit.\n     * @return id         The ERC6909 token identifier of the associated resource lock.\n     */\n    function deposit(address token, uint256 amount, uint256 nonce, uint256 deadline, address depositor, address allocator, ResetPeriod resetPeriod, Scope scope, address recipient, bytes calldata signature)\n        external\n        returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens using Permit2 authorization and\n     * registering a compact. The depositor must approve Permit2 to transfer the tokens on its\n     * behalf unless the token in question automatically grants approval to Permit2. The ERC6909\n     * token amount received by the depositor is derived from the difference between the starting\n     * and ending balance held in the resource lock, which may differ from the amount transferred\n     * depending on the implementation details of the respective token. The Permit2 authorization\n     * signed by the depositor must contain an Activation witness containing the id of the resource\n     * lock and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param token           The address of the ERC20 token to deposit.\n     * @param amount          The amount of tokens to deposit.\n     * @param nonce           The Permit2 nonce for the signature.\n     * @param deadline        The timestamp until which the signature is valid.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param allocator       The address of the allocator mediating the resource lock.\n     * @param resetPeriod     The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @param scope           The scope of the resource lock (multichain or single chain).\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposit.\n     * @return id             The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositAndRegister(\n        address token,\n        uint256 amount,\n        uint256 nonce,\n        uint256 deadline,\n        address depositor,\n        address allocator,\n        ResetPeriod resetPeriod,\n        Scope scope,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens using Permit2\n     * authorization in a single transaction. The first token id can optionally represent native\n     * tokens by providing the null address and an amount matching msg.value. The depositor must\n     * approve Permit2 to transfer the tokens on its behalf unless the tokens automatically\n     * grant approval to Permit2. The ERC6909 token amounts received by the recipient are derived\n     * from the differences between starting and ending balances held in the resource locks,\n     * which may differ from the amounts transferred depending on the implementation details of\n     * the respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * CompactDeposit witness containing the allocator, the reset period, the scope, and the\n     * intended recipient of the deposits.\n     * @param depositor   The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted   Array of token permissions specifying the deposited tokens and amounts.\n     * @param nonce       The Permit2 nonce for the signature.\n     * @param deadline    The timestamp until which the signature is valid.\n     * @param allocator   The address of the allocator mediating the resource locks.\n     * @param resetPeriod The duration after which the resource locks can be reset once forced withdrawals are initiated.\n     * @param scope       The scope of the resource locks (multichain or single chain).\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids        Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function deposit(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        uint256 nonce,\n        uint256 deadline,\n        address allocator,\n        ResetPeriod resetPeriod,\n        Scope scope,\n        address recipient,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory ids);\n\n    /**\n     * @notice External payable function for depositing multiple tokens using Permit2\n     * authorization and registering a compact in a single transaction. The first token id can\n     * optionally represent native tokens by providing the null address and an amount matching\n     * msg.value. The depositor must approve Permit2 to transfer the tokens on its behalf unless\n     * the tokens automatically grant approval to Permit2. The ERC6909 token amounts received by\n     * the depositor are derived from the differences between starting and ending balances held\n     * in the resource locks, which may differ from the amounts transferred depending on the\n     * implementation details of the respective tokens. The Permit2 authorization signed by the\n     * depositor must contain a BatchActivation witness containing the ids of the resource locks\n     * and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted       Array of token permissions specifying the deposited tokens and amounts.\n     * @param nonce           The Permit2 nonce for the signature.\n     * @param deadline        The timestamp until which the signature is valid.\n     * @param allocator       The address of the allocator mediating the resource locks.\n     * @param resetPeriod     The duration after which the resource locks can be reset once forced withdrawals are initiated.\n     * @param scope           The scope of the resource locks (multichain or single chain).\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function depositAndRegister(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        uint256 nonce,\n        uint256 deadline,\n        address allocator,\n        ResetPeriod resetPeriod,\n        Scope scope,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory ids);\n\n    /**\n     * @notice Transfers ERC6909 tokens to a single recipient with allocator approval.\n     * @param transfer A BasicTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the transfer cannot be executed.\n     *  -  id                 The ERC6909 token identifier of the resource lock.\n     *  -  amount             The amount of tokens to transfer.\n     *  -  recipient          The account that will receive the tokens.\n     * @return Whether the transfer was successful.\n     */\n    function allocatedTransfer(BasicTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice Withdraws underlying tokens to a single recipient with allocator approval.\n     * @param withdrawal A BasicTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the withdrawal cannot be executed.\n     *  -  id                 The ERC6909 token identifier of the resource lock.\n     *  -  amount             The amount of tokens to withdraw.\n     *  -  recipient          The account that will receive the tokens.\n     * @return                Whether the withdrawal was successful.\n     */\n    function allocatedWithdrawal(BasicTransfer calldata withdrawal) external returns (bool);\n\n    /**\n     * @notice Transfers ERC6909 tokens to multiple recipients with allocator approval.\n     * @param transfer A SplitTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the transfer cannot be executed.\n     *  -  id                 The ERC6909 token identifier of the resource lock.\n     *  -  recipients         Array of SplitComponents, each containing:\n     *     -  claimant        The account that will receive tokens.\n     *     -  amount          The amount of tokens the claimant will receive.\n     * @return Whether the transfer was successful.\n     */\n    function allocatedTransfer(SplitTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice Withdraws underlying tokens to multiple recipients with allocator approval.\n     * @param withdrawal A SplitTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the withdrawal cannot be executed.\n     *  -  id                 The ERC6909 token identifier of the resource lock.\n     *  -  recipients         Array of SplitComponents, each containing:\n     *     -  claimant        The account that will receive tokens.\n     *     -  amount          The amount of tokens the claimant will receive.\n     * @return Whether the withdrawal was successful.\n     */\n    function allocatedWithdrawal(SplitTransfer calldata withdrawal) external returns (bool);\n\n    /**\n     * @notice Transfers ERC6909 tokens from multiple resource locks to a single recipient with\n     * allocator approval.\n     * @param transfer A BatchTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the transfer cannot be executed.\n     *  -  transfers          Array of TransferComponents, each containing:\n     *     -  id              The ERC6909 token identifier of the resource lock.\n     *     -  amount          The amount of tokens to transfer.\n     *  -  recipient          The account that will receive all tokens.\n     * @return                Whether the transfer was successful.\n     */\n    function allocatedTransfer(BatchTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice Withdraws underlying tokens from multiple resource locks to a single recipient\n     * with allocator approval.\n     * @param withdrawal A BatchTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the withdrawal cannot be executed.\n     *  -  transfers          Array of TransferComponents, each containing:\n     *     -  id              The ERC6909 token identifier of the resource lock.\n     *     -  amount          The amount of tokens to withdraw.\n     *  -  recipient          The account that will receive all tokens.\n     * @return                Whether the withdrawal was successful.\n     */\n    function allocatedWithdrawal(BatchTransfer calldata withdrawal) external returns (bool);\n\n    /**\n     * @notice Transfers ERC6909 tokens from multiple resource locks to multiple recipients\n     * with allocator approval.\n     * @param transfer A SplitBatchTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the transfer cannot be executed.\n     *  -  transfers          Array of SplitByIdComponents, each containing:\n     *     -  id              The ERC6909 token identifier of the resource lock.\n     *     -  portions        Array of SplitComponents, each containing:\n     *        -  claimant     The account that will receive tokens.\n     *        -  amount       The amount of tokens the claimant will receive.\n     * @return                Whether the transfer was successful.\n     */\n    function allocatedTransfer(SplitBatchTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice Withdraws underlying tokens from multiple resource locks to multiple recipients\n     * with allocator approval.\n     * @param withdrawal A SplitBatchTransfer struct containing the following:\n     *  -  allocatorSignature Authorization signature from the allocator.\n     *  -  nonce              Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires            Timestamp after which the withdrawal cannot be executed.\n     *  -  transfers          Array of SplitByIdComponents, each containing:\n     *     -  id              The ERC6909 token identifier of the resource lock.\n     *     -  portions        Array of SplitComponents, each containing:\n     *        -  claimant     The account that will receive tokens.\n     *        -  amount       The amount of tokens the claimant will receive.\n     * @return                Whether the withdrawal was successful.\n     */\n    function allocatedWithdrawal(SplitBatchTransfer calldata withdrawal) external returns (bool);\n\n    /**\n     * @notice External function to initiate a forced withdrawal for a resource lock. Once\n     * enabled, forced withdrawals can be executed after the reset period has elapsed. The\n     * withdrawableAt timestamp returned will be the current timestamp plus the reset period\n     * associated with the resource lock.\n     * @param id              The ERC6909 token identifier for the resource lock.\n     * @return withdrawableAt The timestamp at which tokens become withdrawable.\n     */\n    function enableForcedWithdrawal(uint256 id) external returns (uint256 withdrawableAt);\n\n    /**\n     * @notice External function to disable a previously enabled forced withdrawal for a\n     * resource lock.\n     * @param id The ERC6909 token identifier for the resource lock.\n     * @return   Whether the forced withdrawal was successfully disabled.\n     */\n    function disableForcedWithdrawal(uint256 id) external returns (bool);\n\n    /**\n     * @notice External function to execute a forced withdrawal from a resource lock after the\n     * reset period has elapsed. The tokens will be withdrawn to the specified recipient in the\n     * amount requested. The ERC6909 token balance of the caller will be reduced by the\n     * difference in the balance held by the resource lock before and after the withdrawal,\n     * which may differ from the provided amount depending on the underlying token in question.\n     * @param id        The ERC6909 token identifier for the resource lock.\n     * @param recipient The account that will receive the withdrawn tokens.\n     * @param amount    The amount of tokens to withdraw.\n     * @return          Whether the forced withdrawal was successfully executed.\n     */\n    function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @notice External function to register a claim hash and its associated EIP-712 typehash.\n     * The registered claim hash will remain valid for the specified duration. Once expired, the\n     * claim hash can no longer be used to initiate claims.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered claim hash.\n     * @param duration  The duration for which the claim hash remains valid.\n     * @return          Whether the claim hash was successfully registered.\n     */\n    function register(bytes32 claimHash, bytes32 typehash, uint256 duration) external returns (bool);\n\n    /**\n     * @notice External function to register multiple claim hashes and their associated EIP-712\n     * typehashes in a single call. All registered claim hashes will remain valid for the\n     * specified duration. Once expired, the claim hashes can no longer be used to initiate\n     * claims.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @param duration                 The duration for which the claim hashes remain valid.\n     * @return                         Whether all claim hashes were successfully registered.\n     */\n    function register(bytes32[2][] calldata claimHashesAndTypehashes, uint256 duration) external returns (bool);\n\n    /**\n     * @notice External function for consuming allocator nonces. Only callable by a registered\n     * allocator. Once consumed, any compact payloads that utilize those nonces cannot be claimed.\n     * @param nonces Array of nonces to be consumed.\n     * @return       Whether all nonces were successfully consumed.\n     */\n    function consume(uint256[] calldata nonces) external returns (bool);\n\n    /**\n     * @notice External function for registering an allocator. Can be called by anyone if one\n     * of three conditions is met: the caller is the allocator address being registered, the\n     * allocator address contains code, or a proof is supplied representing valid create2\n     * deployment parameters that resolve to the supplied allocator address.\n     * @param allocator    The address to register as an allocator.\n     * @param proof        An 85-byte value containing create2 address derivation parameters (0xff ++ factory ++ salt ++ initcode hash).\n     * @return allocatorId A unique identifier assigned to the registered allocator.\n     */\n    function __registerAllocator(address allocator, bytes calldata proof) external returns (uint96 allocatorId);\n\n    /**\n     * @notice External view function for checking the forced withdrawal status of a resource\n     * lock for a given account. Returns both the current status (disabled, pending, or enabled)\n     * and the timestamp at which forced withdrawals will be enabled (if status is pending) or\n     * became enabled (if status is enabled).\n     * @param account                      The account to get the forced withdrawal status for.\n     * @param id                           The ERC6909 token identifier of the resource lock.\n     * @return status                      The current ForcedWithdrawalStatus (disabled, pending, or enabled).\n     * @return forcedWithdrawalAvailableAt The timestamp at which tokens become withdrawable if status is pending.\n     */\n    function getForcedWithdrawalStatus(address account, uint256 id) external view returns (ForcedWithdrawalStatus status, uint256 forcedWithdrawalAvailableAt);\n\n    /**\n     * @notice External view function for checking the registration status of a compact. Returns\n     * both whether the claim hash is currently active and when it expires (if it is active).\n     * @param sponsor   The account that registered the compact.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered claim hash.\n     * @return isActive Whether the compact registration is currently active.\n     * @return expires  The timestamp at which the compact registration expires.\n     */\n    function getRegistrationStatus(address sponsor, bytes32 claimHash, bytes32 typehash) external view returns (bool isActive, uint256 expires);\n\n    /**\n     * @notice External view function for retrieving the details of a resource lock. Returns the\n     * underlying token, the mediating allocator, the reset period, and the scope.\n     * @param id           The ERC6909 token identifier of the resource lock.\n     * @return token       The address of the underlying token (or address(0) for native tokens).\n     * @return allocator   The account of the allocator mediating the resource lock.\n     * @return resetPeriod The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @return scope       The scope of the resource lock (multichain or single chain).\n     */\n    function getLockDetails(uint256 id) external view returns (address token, address allocator, ResetPeriod resetPeriod, Scope scope);\n\n    /**\n     * @notice External view function for checking whether a specific nonce has been consumed by\n     * an allocator. Once consumed, a nonce cannot be reused for claims mediated by that allocator.\n     * @param nonce     The nonce to check.\n     * @param allocator The account of the allocator.\n     * @return consumed Whether the nonce has been consumed.\n     */\n    function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool consumed);\n\n    /**\n     * @notice External pure function for returning the domain separator of the contract.\n     * @return domainSeparator A bytes32 representing the domain separator for the contract.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice External pure function for returning the name of the contract.\n     * @return A string representing the name of the contract.\n     */\n    function name() external pure returns (string memory);\n\n    error InvalidToken(address token);\n    error Expired(uint256 expiration);\n    error InvalidSignature();\n    error PrematureWithdrawal(uint256 id);\n    error ForcedWithdrawalAlreadyDisabled(address account, uint256 id);\n    error UnallocatedTransfer(address operator, address from, address to, uint256 id, uint256 amount);\n    error InvalidBatchAllocation();\n    error InvalidRegistrationProof(address allocator);\n    error InvalidBatchDepositStructure();\n    error AllocatedAmountExceeded(uint256 allocatedAmount, uint256 providedAmount);\n    error InvalidScope(uint256 id);\n    error InvalidDepositTokenOrdering();\n    error InvalidDepositBalanceChange();\n    error Permit2CallFailed();\n    error InvalidRegistrationDuration(uint256 duration);\n    error ReentrantCall(address existingCaller);\n}\n","metadata":{"source":"code","createdAt":"1970-01-21T04:51:01.913Z","relevanceScore":0.64836603,"url":null,"mimeType":"application/solidity","tokenCount":9286}}],"generatedText":"","metadata":{"startTime":1745763667906,"runId":"aa6ee597-77df-42f7-898c-766720be8a25","traceId":"trace-cli-user-1745763667935","spanId":"trace-cli-user-1745763667935-retrieve-1745763669740","currentNode":"generate_answer","nodeTimings":{"splitRewrite":1805,"retrieve":720},"tokenCounts":{"originalQuery":7,"rewrittenQuery":7,"retrievedDocs":29246},"isFinalState":true}},"msg":"CHAT RESPONSE!!"}
