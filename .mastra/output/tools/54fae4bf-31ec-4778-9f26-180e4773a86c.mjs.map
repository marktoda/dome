{"version":3,"file":"54fae4bf-31ec-4778-9f26-180e4773a86c.mjs","sources":["../../../src/mastra/tools/notes-tool.ts"],"sourcesContent":["import { createTool } from \"@mastra/core/tools\";\nimport { z } from \"zod\";\nimport fg from \"fast-glob\";\nimport fs from \"node:fs/promises\";\nimport matter from \"gray-matter\";\nimport { join, basename, extname } from \"node:path\";\nimport crypto from \"node:crypto\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst vaultPath = process.env.DOME_VAULT_PATH ?? `${process.env.HOME}/dome`;\n\ninterface NoteMeta {\n  id: string;\n  title: string;\n  date: string;\n  tags: string[];\n  path: string;\n  source: \"cli\" | \"external\";\n}\n\ninterface Note extends NoteMeta {\n  body: string;\n}\n\nexport const listNotesTool = createTool({\n  id: \"listNotes\",\n  description: \"List all note metadata from the local vault\",\n  inputSchema: z.object({}),\n  outputSchema: z.array(z.object({\n    id: z.string(),\n    title: z.string(),\n    date: z.string(),\n    tags: z.array(z.string()),\n    path: z.string(),\n    source: z.enum([\"cli\", \"external\"])\n  })),\n  execute: async () => {\n    return listNotes();\n  }\n});\n\nexport const getNoteTool = createTool({\n  id: \"getNote\",\n  description: \"Get a specific note by ID or path from the local vault\",\n  inputSchema: z.object({\n    idOrPath: z.string().describe(\"Note ID or file path (e.g., 'inbox/my-note.md')\")\n  }),\n  outputSchema: z.union([\n    z.object({\n      id: z.string(),\n      title: z.string(),\n      date: z.string(),\n      tags: z.array(z.string()),\n      path: z.string(),\n      source: z.enum([\"cli\", \"external\"]),\n      body: z.string()\n    }),\n    z.null()\n  ]),\n  execute: async ({ context }) => {\n    return getNote(context.idOrPath);\n  }\n});\n\nexport const writeNoteTool = createTool({\n  id: \"writeNote\",\n  description: \"Create a new note or append content to an existing note. Perfect for running meeting notes or iterative content.\",\n  inputSchema: z.object({\n    title: z.string().describe(\"The title of the note (used for creation or finding existing note)\"),\n    content: z.string().describe(\"The markdown content to write or append\"),\n    mode: z.enum([\"create\", \"append\", \"auto\"]).default(\"auto\").describe(\"'create' forces new note, 'append' adds to existing, 'auto' creates if not found or appends if found\"),\n    tags: z.array(z.string()).optional().describe(\"Optional tags for the note (only used when creating)\"),\n    folder: z.string().optional().describe(\"Optional subfolder (e.g., 'inbox', 'meetings')\"),\n    idOrPath: z.string().optional().describe(\"Specific note ID or path to append to (overrides title-based lookup)\")\n  }),\n  outputSchema: z.object({\n    id: z.string(),\n    title: z.string(),\n    date: z.string(),\n    tags: z.array(z.string()),\n    path: z.string(),\n    source: z.enum([\"cli\", \"external\"]),\n    fullPath: z.string(),\n    action: z.enum([\"created\", \"appended\"]),\n    contentLength: z.number()\n  }),\n  execute: async ({ context }) => {\n    return writeNote(\n      context.title, \n      context.content, \n      context.mode, \n      context.tags, \n      context.folder, \n      context.idOrPath\n    );\n  }\n});\n\nasync function listNotes(): Promise<NoteMeta[]> {\n  try {\n    const paths = await fg(\"**/*.md\", { cwd: vaultPath, dot: false });\n    const metas = await Promise.all(paths.map(parseMeta));\n    return metas.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n  } catch (error) {\n    console.error(\"Error listing notes:\", error);\n    return [];\n  }\n}\n\nasync function getNote(idOrPath: string): Promise<Note | null> {\n  try {\n    const fullPath = await resolvePath(idOrPath);\n    if (!fullPath) return null;\n    \n    const raw = await fs.readFile(fullPath, \"utf8\");\n    const { data, content } = matter(raw);\n    const meta = await deriveMeta(data, fullPath);\n    return { ...meta, body: content };\n  } catch (error) {\n    console.error(\"Error getting note:\", error);\n    return null;\n  }\n}\n\nasync function parseMeta(relativePath: string): Promise<NoteMeta> {\n  const full = join(vaultPath, relativePath);\n  try {\n    const raw = await fs.readFile(full, \"utf8\");\n    const { data } = matter(raw);\n    return deriveMeta(data, full);\n  } catch (error) {\n    console.error(`Error parsing meta for ${relativePath}:`, error);\n    // Return fallback meta\n    const stat = await fs.stat(full).catch(() => ({ birthtime: new Date() }));\n    const fileName = basename(full, extname(full));\n    return {\n      id: crypto.createHash(\"sha1\").update(full).digest(\"hex\"),\n      title: fileName,\n      date: stat.birthtime.toISOString(),\n      tags: [],\n      path: relativePath,\n      source: \"external\"\n    };\n  }\n}\n\nasync function deriveMeta(data: any, fullPath: string): Promise<NoteMeta> {\n  const stat = await fs.stat(fullPath).catch(() => ({ birthtime: new Date() }));\n  const fileName = basename(fullPath, extname(fullPath));\n  const relativePath = fullPath.replace(`${vaultPath}/`, \"\");\n  \n  let title = data.title ?? fileName;\n  \n  // If no title in front-matter, try to extract from first heading\n  if (!data.title) {\n    try {\n      const raw = await fs.readFile(fullPath, \"utf8\");\n      const headingMatch = raw.match(/^#\\s+(.*)$/m);\n      if (headingMatch) {\n        title = headingMatch[1];\n      }\n    } catch (error) {\n      // Keep fileName as fallback\n    }\n  }\n  \n  return {\n    id: data.id ?? crypto.createHash(\"sha1\").update(fullPath).digest(\"hex\"),\n    title,\n    date: data.date ?? stat.birthtime.toISOString(),\n    tags: Array.isArray(data.tags) ? data.tags : [],\n    path: relativePath,\n    source: data.source ?? \"external\"\n  };\n}\n\nasync function resolvePath(idOrPath: string): Promise<string | null> {\n  try {\n    // If it looks like a path, try it directly\n    if (idOrPath.endsWith(\".md\")) {\n      const fullPath = join(vaultPath, idOrPath);\n      await fs.access(fullPath);\n      return fullPath;\n    }\n    \n    // Otherwise, search by ID\n    const metas = await listNotes();\n    const hit = metas.find(m => m.id === idOrPath);\n    return hit ? join(vaultPath, hit.path) : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nasync function writeNote(\n  title: string,\n  content: string,\n  mode: \"create\" | \"append\" | \"auto\" = \"auto\",\n  tags: string[] = [],\n  folder?: string,\n  idOrPath?: string\n): Promise<NoteMeta & { fullPath: string; action: \"created\" | \"appended\"; contentLength: number }> {\n  try {\n    // Ensure vault directory exists\n    await fs.mkdir(vaultPath, { recursive: true });\n\n    let existingNote: Note | null = null;\n    let targetPath: string | null = null;\n\n    // First, try to find existing note\n    if (mode !== \"create\") {\n      if (idOrPath) {\n        // Use specific ID or path\n        existingNote = await getNote(idOrPath);\n        targetPath = await resolvePath(idOrPath);\n      } else {\n        // Search for note by title\n        const notes = await listNotes();\n        const foundNote = notes.find(n => \n          n.title.toLowerCase() === title.toLowerCase()\n        );\n        if (foundNote) {\n          existingNote = await getNote(foundNote.id);\n          targetPath = join(vaultPath, foundNote.path);\n        }\n      }\n    }\n\n    // If we found an existing note and mode allows appending\n    if (existingNote && targetPath && mode !== \"create\") {\n      return await appendToNote(existingNote, targetPath, content);\n    }\n\n    // If mode is \"append\" but no existing note found, throw error\n    if (mode === \"append\") {\n      throw new Error(`Note not found for appending: ${idOrPath || title}`);\n    }\n\n    // Create new note\n    return await createNewNote(title, content, tags, folder);\n\n  } catch (error) {\n    console.error(\"Error writing note:\", error);\n    throw new Error(`Failed to write note: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nasync function createNewNote(\n  title: string,\n  content: string,\n  tags: string[] = [],\n  folder?: string\n): Promise<NoteMeta & { fullPath: string; action: \"created\"; contentLength: number }> {\n  // Create subfolder if specified\n  const targetDir = folder ? join(vaultPath, folder) : vaultPath;\n  await fs.mkdir(targetDir, { recursive: true });\n  \n  // Generate timestamp-slug filename\n  const now = new Date();\n  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD\n  const slug = title\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s-]/g, '') // Remove special chars\n    .replace(/\\s+/g, '-') // Replace spaces with hyphens\n    .replace(/-+/g, '-') // Collapse multiple hyphens\n    .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens\n  \n  const fileName = `${dateStr}-${slug}.md`;\n  const relativePath = folder ? join(folder, fileName) : fileName;\n  const fullPath = join(vaultPath, relativePath);\n  \n  // Generate unique ID\n  const id = uuidv4();\n  \n  // Create YAML front-matter\n  const frontMatter = {\n    id,\n    title,\n    date: now.toISOString(),\n    tags,\n    source: \"cli\"\n  };\n  \n  // Combine front-matter and content\n  const fileContent = matter.stringify(content, frontMatter);\n  \n  // Write the file\n  await fs.writeFile(fullPath, fileContent, 'utf8');\n  \n  return {\n    id,\n    title,\n    date: now.toISOString(),\n    tags,\n    path: relativePath,\n    source: \"cli\",\n    fullPath,\n    action: \"created\",\n    contentLength: content.length\n  };\n}\n\nasync function appendToNote(\n  existingNote: Note,\n  targetPath: string,\n  newContent: string\n): Promise<NoteMeta & { fullPath: string; action: \"appended\"; contentLength: number }> {\n  // Read the current file to preserve front-matter\n  const currentFileContent = await fs.readFile(targetPath, 'utf8');\n  const { data: frontMatter, content: currentContent } = matter(currentFileContent);\n  \n  // Append new content with proper spacing\n  const separator = currentContent.trim() ? '\\n\\n' : '';\n  const updatedContent = currentContent + separator + newContent;\n  \n  // Update the modified date in front-matter\n  const updatedFrontMatter = {\n    ...frontMatter,\n    modified: new Date().toISOString()\n  };\n  \n  // Combine updated front-matter and content\n  const updatedFileContent = matter.stringify(updatedContent, updatedFrontMatter);\n  \n  // Write the updated file\n  await fs.writeFile(targetPath, updatedFileContent, 'utf8');\n  \n  return {\n    id: existingNote.id,\n    title: existingNote.title,\n    date: existingNote.date,\n    tags: existingNote.tags,\n    path: existingNote.path,\n    source: existingNote.source,\n    fullPath: targetPath,\n    action: \"appended\",\n    contentLength: newContent.length\n  };\n}"],"names":["uuidv4"],"mappings":"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"}